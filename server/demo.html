<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>

</body>
<script>
  /* 
    数组求和
    不允许使用循环
    不允许使用标准库的函数
    f(i)表示从数组的i位到末尾之和
    f(i)和f(i+1)之间的关系
    f(i) = f(i+1)+nums[i]
  */
  /* const nums = [5, 1, 3, 6, 2]

  function sum(i = 0) {
    return i >= nums.length ? 0 : nums[i] + sum(i + 1)
  }
  console.log(sum()) */
  // 手写instanceof
  /*   function myInstanceOf(left, right) {
      // 首先用typeof来判断基本数据类型，如果是直接返回false
      if (typeof left !== 'object' || left === null) {
        return false;
      }
    }

    function instance_of(L, R) { //L 表示左表达式，R 表示右表达式 
      var O = R.prototype; // 取 R 的显示原型 
      L = L.__proto__; // 取 L 的隐式原型
      while (true) {
        if (L === null)
          return false;
        if (O === L) // 当 O 显式原型 严格等于  L隐式原型 时，返回true
          return true;
        L = L.__proto__;
      }
    } */
  /*  function getType(obj) {
     const type = typeof obj
     if (type !== 'object') {
       return type
     }
     return Object.prototype.toString.call(obj).split(' ')[1].replace(']', '')
   }
   console.log(getType(null)) */
  /* setTimeout(function () {
    console.log('4')
  })

  new Promise(function (resolve) {
    console.log('1') // 同步任务
    resolve()
  }).then(function () {
    console.log('3')
  })
  console.log('2') */

  /*   console.log('1')
    setTimeout(function () {
      console.log('2')
      process.nextTick(function () {
        console.log('3')
      })
      new Promise(function (resolve) {
        console.log('4')
        resolve()
      }).then(function () {
        console.log('5')
      })
    })

    process.nextTick(function () {
      console.log('6')
    })

    new Promise(function (resolve) {
      console.log('7')
      resolve()
    }).then(function () {
      console.log('8')
    })

    setTimeout(function () {
      console.log('9')
      process.nextTick(function () {
        console.log('10')
      })
      new Promise(function (resolve) {
        console.log('11')
        resolve()
      }).then(function () {
        console.log('12')
      })
    }) */
  /* 1-7-6-8-2-4-3-5-9-11-10-12*/
  /*   new Promise(function (resolve) {
      console.log('1') // 宏任务一
      resolve()
    }).then(function () {
      console.log('3') // 宏任务一的微任务
    })
    setTimeout(function () { // 宏任务二
      console.log('4')
      setTimeout(function () { // 宏任务五
        console.log('7')
        new Promise(function (resolve) {
          console.log('8')
          resolve()
        }).then(function () {
          console.log('10')
          setTimeout(function () { // 宏任务七
            console.log('12')
          })
        })
        console.log('9')
      })
    })
    setTimeout(function () { // 宏任务三
      console.log('5')
    })
    setTimeout(function () { // 宏任务四
      console.log('6')
      setTimeout(function () { // 宏任务六
        console.log('11')
      })
    })
    console.log('2') // 宏任务一 */
  /* 1-2-3-4-5-6-7-8-9-10-11-12 */

  /* async function async1() {
    console.log('2')
    const data = await async2()
    console.log(data)
    console.log('8')
  }

  async function async2() {
    return new Promise(function (resolve) {
      console.log('3')
      resolve('await的结果')
    }).then(function (data) {
      console.log('6')
      return data
    })
  }
  console.log('1')

  setTimeout(function () {
    console.log('9')
  }, 0)

  async1()

  new Promise(function (resolve) {
    console.log('4')
    resolve()
  }).then(function () {
    console.log('7')
  })
  console.log('5') */
  // 获取数据类型
  /* const getType = (data) => {
    if (typeof data !== 'object') return typeof data
    return Object.prototype.toString.call(data).split(' ')[1].slice(0, -1)
  }
  console.log(getType(null)) */
  /* function Cat() {

  }
  const cat = new Cat()
  console.log(cat) */
  // 手写instanceof
  /*   const myInstanceOf = (left, right) => {
      let L = left.__proto__
      let R = right.prototype
      if (left === null || typeof left !== 'object') return false
      while (true) {
        if (L === null) return false
        if (L === R) return true
        L = L.__proto__
        console.log(L)
      }
    }
    console.log(myInstanceOf({}, Array)) */
  // 手写new操作符
  /*   const myNew = (fn) => {
      let obj = {}
      obj.__proto__ = fn.prototype
      const reult = fn.call(obj)
      if (reult && (typeof reult == 'object') || typeof reult == 'function') {
        return result
      }
      return obj
    } */
  Function.prototype.myCall = function (thisArg = window) {
    console.log(this, 'this')
    thisArg.fn = this
    const args = [...arguments].slice(1)
    const result = thisArg.fn(...args)
    delete thisArg.fn
    return result
  }

  function foo() {
    console.log(this.name, 1);
  }
  const obj = {
    name: 'litterStar'
  }
  const bar = function () {
    foo.myCall(obj);
  }
  bar()
</script>

</html>